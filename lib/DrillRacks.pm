#--------------------------------------------------------------------#
#
#   project:  gbtiler 2.0
#  filename:  DrillRacks.pm
#   created:  2002-11-21
#  modified:  2007-03-05
#
#...;....1....;....2....;....3....|....4....;....5....;....6....;....7



#--------------------------------------------------------------------#
#
#  SYNOPSIS:
#
#  This Perl script reads and parses information about the sizes of
#  drill bits which NC drill files specify as the tools to use in
#  circuit board designs.  This script currently "understands" files
#  generated by Protel98 and EAGLE 4.xx circuit design programs.
#
#  Source drill files are passed to this script in a hash reference
#  that represents a layer from one or more circuit boards to be
#  tiled.  Drill tool information may appear embedded in the drill
#  files themselves, or in separate rack files.
#
# --------------------------------------------------------------------
#
#
#
#
#  IMPLEMENTATION:
#
#  The DrillRacks package stores what are either embedded drill racks
#  or external drill racks stored in separate files.  These typically
#  short ( less than 40 ) drill size descriptions are stored in arrays
#  within the hash key for each source drill file.
#
#  After gathering and storing drill racks, another routine reads and
#  parses the stored lists as part of the work to build a master drill
#  rack.
#
#  At the start of this script, the hierarchical structure of a
#  typical drill layer hash looks like,
#
#  layer
#   +-drillFile001
#   +-drillFile002
#   +-drillFile003
#      +-filename
#      +-filetype
#      +-xOffset
#      +-yOffset
#      +-rackfile
#      +-generatedBy
#
#  For each drill file a drill rack key is added, and to the layer
#  itself a master drill rack key is added.  These keys all point to
#  hashes, whose keys are named as the drills and point to drill
#  sizes.  In the case of the master drill rack those keys point to
#  drill sizes, original drill names and new drill names.
#
# --------------------------------------------------------------------
#
#
#
#
#  GERBER FILE DETAILS:
#
#  An example embedded drill rack:
#
#     M48
#     T01C0.020
#     T02C0.024
#     T03C0.028
#     G90
#     M72
#     %
#
#
#  An external drill rack ( Ted needs to check whether Protel'9x or
#  EagleCAD generates this format of drill rack file and statement. )
#
#     T01 0.032in^M
#     T02 0.035in^M
#     T03 0.040in^M
#
#
#  Note:  the <control-M> characters are probably a DOS artifact and
#  are either carriage returns or line feeds.  Some text processing
#  lines in the gbtiler, namely those that remove white space, remove
#  these characters also.  This in turns means that back in the
#  Windows world the tiled drill and gerber files by default generally
#  appear as a single, long wrapping line in the program Notepad.exe.
#
# --------------------------------------------------------------------
#
#
#
#
#  VERSIONS HISTORY:
#
#  2002-10      drilltiler version 1.0
#
#  2003-08-26   drilltiler version 2.0
#
#  2004-07-14   added trace hash at top level of $self internal data
#               structure.
#
#  2004-07-xx   incorporated into gbtiler version 2.0
#
# --------------------------------------------------------------------
#
#
#
#
#  AUTHORS:
#
#  Ted Havelka    ted@cs.pdx.edu
#
#--------------------------------------------------------------------#



package DrillRacks;
use strict;

# use strict;   # ...author Ted Havelka would use Perl's 'use strict'
                #    option, but finds that this option always
                #    complains and never gets past the anonymous
                #    hash declaration in the constructor routine
                #    named 'new'.

our ($ERRSTR);
our $self = {};



#====================================================================#
#                                                                    #
#   Constructor:                                                     #
#                                                                    #
#====================================================================#

sub new
{

## Define the run-time persistent data structure of this Perl package:
## -------------------------------------------------------------------
   my ($class) = @_; 
   $self =

   {

      projectName => 0,      # name of project to which this package
                             # belongs

      packageName => 0,      # name of this package

      diagnostic  => 0,      # reference to a diagnostics package

      trace       => {},     # a routine-tracing flag

      useCount    => 0,      # holds running count of this scripts
                             # executions per tiling job



      layer       => {},     # hash of drill files to tile, plus
                             # their pertinent information.

      drillRackLines => 0,   # an array of drill rack lines from the
                             # current drill file.

   };



## Initialize some object data:

   $self->{projectName} = "NO PROJECT NAME SET";
   $self->{packageName} = "DrillRacks.pm";
   $self->{useCount}    = 0;

   $self->{trace}{new}                     = 0;
   $self->{trace}{initialize}              = 0;
   $self->{trace}{store_drill_racks}       = 0;
   $self->{trace}{store_rack_embedded}     = 0;

   $self->{trace}{add_drill}               = 1;   # not in use
   $self->{trace}{check_for_substitution}  = 0;

   $self->{trace}{build_master_drill_rack} = 0;
   $self->{trace}{write_master_drill_rack} = 0;



## Let the data structures of this object know their class:

   bless($self, $class); 

   return $self ;

}





sub initialize
{
#--------------------------------------------------------------------#
#
#  RECEIVE:  +  a reference to a diagnostics object
#
#            +  an optional debug string to enable or disable
#               tracing of various routines in this package.
#
#  RETURN:   nothing
#
#  PURPOSE:  This routine initializes some of the data members that
#  are a part of this Perl package, and function in a global way
#  while a program which includes this package is executing.
#
#--------------------------------------------------------------------#

   my $self  = shift;

   my $rname;        # string, name of this routine
   my $trace;        # integer as boolean, set in 'new' routine
   my $msg;          # string, for diagnostics


## Initialize local variables:

   $rname = "initialize";
   $trace = $self->{trace}{$rname};




## Set a reference to a diagnostics package:

   if (@_)
   {
      $self->{diagnostic} = shift;
   }
   else
   {
      $msg  = "$rname:  ERROR\n";
      $msg .= "$rname:  In an instance of '$self->{package}' package, received\n";
      $msg .= "$rname:  no reference to 'Diagnostics' package instance.\n";
      $msg .= "$rname:  \n";
      print $msg;
   }



## If provided, set a project name, naming the project to which this
## package belongs:

   if (@_)
   {
      $self->{diagnostic}{projectName} = shift;
   }
   else
   {
      $msg .= "$rname:  in package '$self->{package}', no project name received.\n";
      $msg .= "$rname:  \n";
      print $msg;
   }



#--------------------------------------------------------------------#
#  Normally this conditional diagnostic block appears at the top     #
#  of routines, as a standard way author Ted Havelka developed to    #
#  to trace routine calls in Perl scripts.                           #
#--------------------------------------------------------------------#

   if ($trace)
   {
      $msg  = "$rname:  in package $self->{packageName}, just completed\n";
      $msg .= "$rname:  initializing routine.  Returning to caller...\n\n";
      print $msg;
   }

}





#====================================================================#
#                                                                    #
#   Data access methods:                                             #
#                                                                    #
#====================================================================#


sub store_drill_racks
{
#--------------------------------------------------------------------#
#
#  PURPOSE:
#
#  To receive a hash holding a layer of NC drill file keys and other
#  drill layer related data.  For each file, call as appropriate a
#  routine to read either embedded drill sizes or drill sizes stored
#  in an external file, often called a rack file.
#
#--------------------------------------------------------------------#
   my $self = {};
   $self = shift;


## Local variables declared, in order of use:

   my $drillFileKey;       # string, used to step through hash keys
   my $drillFileName;      # string, holds name of NC drill file
   my $drillName;          # string,
   my $drillSize;          # string,


   my $rname = "store_drill_racks";   # name of this routine
   my $trace = $self->{trace}{$rname};
   my $msg   = "";                   # diagnostics string
   my ($rackfile, $line); 

   

## Some initial diagnostics:

   $self->{useCount}++;
   $msg = "$rname:  in package '$self->{packageName}',\n";
   $msg .= "$rname:  this routine has now started '$self->{useCount}' times,\n";
   $msg .= "$rname:  \n";
   print $msg if ($trace);

   


## Get and store a copy of the drill layer to tile:

   $self->{layer} = shift;
   
  
   

## Cycle through all files to be tiled, checking for external rack
## files and embedded drill racks:


   foreach $drillFileKey ( sort keys %{$self->{layer}} )
   {
      
       if ( $drillFileKey =~ /^infile_/ )
      {
         
	  $drillFileName = $self->{layer}{$drillFileKey}{filename};
      
## -------------------------------------------------------------------
## 2004-08-05
##
## Here in this IF block process external drill rack files.  These
## files typically contain only drill rack lines, each expressing a
## single drill name and drill size pair.  Because these files are so
## short and simple, the code here only filters lines to ensure that
## they match a pattern of the form,
##
##    T + digits + alpha + digits + . + digits
##
## Some lines will have additional text following the drill size.
## This text is dropped in the final, tiled drill layer output
## generated by this script.
##
##
##
## 2004-08-06
##
## It turns out that some Protel generated drill files may also have
## drill rack lines with apparently longer drill names, where lines
## here are of the form,
##
##    T + (digits and alphas) + (space or 'C') + digits + . + digits
##
## An example of such a line developer Ted found is,
##
##    T1F00S00C0.028
##
## -------------------------------------------------------------------
         
         if ( exists $self->{layer}{$drillFileKey}{rackfile} )
         {
           
            $msg = "$rname:  found external rackfile for file '$drillFileName',\n";
            print $msg if ($trace);

            $rackfile = $self->{layer}{$drillFileKey}{rackfile};
            




            if (open(RACKFILE, "< $rackfile"))
            {
               while ( $line = <RACKFILE> )
               {
                  
#                 if ( ($drillName, $drillSize) = $line =~ /(^T\d+)[ C](\d+\.\d+)/ )
                  if ( ($drillName, $drillSize) = $line =~ /(^T.+)[ C](\d+\.\d+)/ )

                  {  
                     $self->{layer}{$drillFileKey}{drills}{$drillName}{size} = $drillSize;
                     $self->{layer}{$drillFileKey}{drills}{$drillName}{newName} = $drillSize;
                  } 
               }

               close(RACKFILE);
            }

            else
            {
               $msg = "$rname:  ERROR\n";
               $msg .= "$rname:  could not open external rack file '$rackfile',\n";
               $msg .= "$rname:  can't read drill info for source file '$drillFileName',\n";
               $msg .= "$rname:  \n";
               print $msg;
            }
         }



## Else in the case of parsing embedded drill rack information:

         else
         {
            $msg = "$rname:  no external rackfile for file '$drillFileName',\n";
            print $msg if ($trace);
      
            store_rack_embedded( $drillFileKey );
            
         } # . . . . . .  handle either embedded or external rack file

      } # . . . . . . . . . . . . . process each source drill file key

   } # . . . . . . . . .  cycle through all keys in current drill layer



}





sub store_rack_embedded
{
#--------------------------------------------------------------------#
#
#  PURPOSE:
# 
# 
# 
#  IMPLEMENTATION: 
# 
#  The basic algorithm here is to scan an NC drill file for the code
#  M48.  This signals the beginning of an embedded drill size list.
#  Then, all consecutive lines ollowing the M48 code, lines which
#  begin with the pattern TnnCn.nnnn, where n is a digit (0..9), are
#  parsed for their drill name and drill size information.
# 
#  Codes G90 and M72 appear to signal the end of an embedded drill
#  size list in an NC drill file.  However, the algorithm in this
#  routine parses consecutive drill size lines until it comes to the
#  next line that fails to match the tool line pattern.
# 
#--------------------------------------------------------------------#

## Declare local variables, assign values to some of them:

   my $drillFileKey;
   $drillFileKey = shift;
   
   my $drillFilename;          # string,
   my $M48;                    # integer, used as boolean flag
   my $line;                   # string,
   my $parsingEmbeddedRack;    # integer, used as boolean flag



## Local diagnostic variables:

   my $rname = "store_rack_embedded";
   my $trace = $self->{trace}{store_rack_embedded};
   my $msg = "";
   my ($drillFileName, $drillName, $drillSize) = (' ', ' ', 0); 



   $drillFileName = $self->{layer}{$drillFileKey}{filename};

  


   if (open(DRILLFILE, "< $drillFileName"))
   {

## Setting up some flags and looping to parse embedded drill rack:

      $M48 = 0;
      $line = " ";
      $parsingEmbeddedRack = 1;
 

      while (defined($line) && ($line = <DRILLFILE>) && $parsingEmbeddedRack)
      {  
         chomp($line);
         $msg = "$rname:  current line from file equals '$line',\n";
         print $msg if ($trace);
    
         if ($M48) 
         {

## -------------------------------------------------------------------
## 2004-08-06
##
## Modifying the pattern match and assignment line,
##
##    if ( ($drillName, $drillSize) = $line =~ /(^T\d+)[ C](\d+\.\d+)/ )
##
## to accomodate drill rack lines of type,
##
##    T1F00S00C0.028
##
## which appear in embedded drill racks, but differ from the drill
## tool directives among the NC drill coordinate data.
## -------------------------------------------------------------------

            if ( ($drillName, $drillSize) = $line =~ /(^T.+)[ C](\d+\.\d+)/ )
            {
             
$msg = "$rname:  in embedded rack found drill named '$drillName',\n";
print $msg if ($trace);

               if ( $line !~ /(^T\d+)[ C](\d+\.\d+)/ )
               {
                  ($drillName) = $line =~ /^T(\d+)/;
                  $drillName = sprintf("T%0*d", 2, $drillName);
                  
$msg = "$rname:  building new drill name '$drillName',\n";
print $msg if ($trace);

               }

               $self->{layer}{$drillFileKey}{drills}{$drillName}{size} = $drillSize;
               $self->{layer}{$drillFileKey}{drills}{$drillName}{newName} = $drillSize;

$msg = "$rname:  in source file hash '$drillFileKey' stored drill named '$drillName',\n";
$msg .= "$rname:  \n";
print $msg if ($trace);

            }

         
            elsif ( $line =~ /^%/ )   
            {
               $parsingEmbeddedRack = 0;

               $msg = "$rname:  passed last consecutive tool line,\n";
               $msg .= "$rname:  current line holds '$line',\n";
               print $msg if ($trace);
            }

         }


         if ($line =~ /^M48/)
         {
            $M48 = 1;
            $msg = "$rname:  Found M48 opening drill rack code,\n";
            print $msg if ($trace);
         }

      }

      close(DRILLFILE);
   }


   else
   {
      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  can't open '$drillFilename' for reading,\n";
      $msg .= "$rname:  returning to caller...\n\n";
      print $msg;
   }

}





sub add_drill
{
#--------------------------------------------------------------------#
#
#  RECEIVE:  + a drill file key,
#
#            +  an embedded drill rack line of the current drill file
#
#  PURPOSE:
#
#--------------------------------------------------------------------#


   my $drillFileKey = shift;   # current drill file hash key

   my $line = shift;           # embedded rack line from drill file



## Additional local variable declarations:

   my $drillName = "";         # string,
   my $drillSize = "";         # string,

   my $rname = "add_drill";
   my $trace = $self->{trace}{add_drill};
   my $msg   = "";
   my $filename = "";




## Check for zero-length hash key names, which Perl will dutifully
## create even though their presence indicates that something has gone
## wrong elsewhere:

   if ( length($drillFileKey) < 1 )
   {
      $msg = "$rname:  Hey, got called with a drill file key name of length ZERO!\n";
      $msg = "$rname:  something's wrong here.  Returning to caller...\n\n";
      print $msg;
      return (0);
   }



## -------------------------------------------------------------------
##
## PARSING DETAILS:
##
## The following IF - ELSIF construct parses for drill rack lines
## of the form:
##
##
##    T + digits + alpha + digits + . + digits
##
##
## This series of character groups contains tool name and size
## information stored in this way,
##
##
##    ( T + digits ) + alpha + ( digits + . + digits )
##      ^^^^^^^^^^               ^^^^^^^^^^^^^^^^^^^
##      drill name                    drill size
##
## -------------------------------------------------------------------



## NOTE:  $1, $2, $3 and so on are Perl built-in variables that hold
## the results -- often substrings -- of pattern matching
## expressions.


#  if ( $line =~ /T(\d+)C(\d\.\d+)/ )
#  {
#     $drillName = $1;
#     $drillSize = $2;
#  }

#  elsif ( $line =~ /T(\d+) (\d\.\d+)/ )
#  {
#     $drillName = $1;
#     $drillSize = $2;
#  }


   if ( ($drillName, $drillSize) = $line =~ /(^T\d+)[ C](\d+\.\d+)/ )
   {
   }

   else 
   {
      $msg = "$rname:  found unexpected tool line: '$line',\n";
      $msg .= "$rname:  returning to caller...\n\n";
      print ($msg) if $trace;
      return;
   }



   $self->{layer}{$drillFileKey}{drills}{$drillName}{size} = $drillSize;
   $self->{layer}{$drillFileKey}{drills}{$drillName}{newName} = "";


   $filename = $self->{layer}{$drillFileKey}{filename};
   $msg = "$rname:  in layer hash key named '$drillFileKey',\n";
   $msg .= "$rname:  for source drill file '$filename',\n";
   $msg .= "$rname:  parsed and added tool '$drillName', drill size '$drillSize',\n";
   $msg .= "$rname:  returning to caller...\n\n";
   print ($msg) if $trace;

}





sub check_for_substitution
{
#--------------------------------------------------------------------#
#
#  NOTES:  
#
#  2003-11-03
#  this routine called only internally, and called at two
#  points during drill rack processing.
#
#  2004-08-03
#  The series of assignments contingent on IF statements is
#  particular to one set of gerber files.  A more generalized routine
#  would accept a list of substitutions, or look for such a list in
#  the tiling job hash tree.
#
#--------------------------------------------------------------------#

   my $drillSize = shift;
   my $size = 0;

   $size = $drillSize;

   $size = 0.020 if ($drillSize == 0.024);
   $size = 0.035 if ($drillSize == 0.032);
   $size = 0.042 if ($drillSize == 0.040);
   $size = 0.052 if ($drillSize == 0.050);
   $size = 0.060 if ($drillSize == 0.056);
   $size = 0.060 if ($drillSize == 0.059);
   $size = 0.060 if ($drillSize == 0.0595);
   $size = 0.125 if ($drillSize == 0.100);

   $size = sprintf("%1.4f", $size);

   return $size;

}





sub build_master_drill_rack
{

## -------------------------------------------------------------------
##
## PURPOSE: 
##
## to build a master drill rack, a list of drill names and their
## sizes, along side the source drill files in the job hash table.
##
##
## IMPLEMENTATION AND STRATEGY:
##
## Original drill racks for each source file are stored as hashes
## with drill names as the indexing keys.  The master drill rack in
## constrast uses drill sizes as the names of indexing keys.  In this
## way it is simple to test for the presence of a particular drill
## size in the master rack.  When a drill size is already in the
## master rack, the action this routine then takes is to update the
## given original file's stored drill rack, so that the original
## drill name maps to the corresponding name (sometimes the same,
## often different) in the master rack.
##
## And again, a drill rack is a list of drill names and sizes.
##
##
## Note the additition of the master rack key in this script's top
## level hash key named 'layer'.  Adding the master rack key in this
## way actually modifies the NC drill layer of the current tiling job,
## because the layer key within this script is a reference to part of
## gbtiler's job hash table.
##
## -------------------------------------------------------------------


   my $self = shift;


   my $uniqueDrillCount;   # integer, numeric part of new drill names
   my $drillSubstitution;  # integer, acts as boolean flag
   my $drillFileKey;       # string, name of hash key for source file
   my $drill;              # string,
   my $size;               # real or float value,
   my $index;              # string,
   my $newDrillName;       # string,


   my $rname = "build_master_drill_rack";
   my $trace = $self->{trace}{$rname};
   my $msg;
   my ($filename, $trace_master_rack_summary) = (' ', 0); 



## -------------------------------------------------------------------
## Some set up...
## -------------------------------------------------------------------

## instantiating a sub hash for the master drill rack:


   $self->{layer}{masterRack} = {};




## initialize the numeric value for the first drill encountered:


   $uniqueDrillCount = 1;




## set a flag to toggle on and off Alberte Printed Circuit style drill
## size substitution:


   $drillSubstitution = $self->{layer}{drillSubstitution};
   



## -------------------------------------------------------------------
## Process each soure drill file key in the current layer:
## -------------------------------------------------------------------

   foreach $drillFileKey ( sort keys %{$self->{layer}} )
   {
       
      if ( $drillFileKey =~ /^infile_/ )
      {

         foreach $drill ( keys %{$self->{layer}{$drillFileKey}{drills}} )
         {  
            $size = $self->{layer}{$drillFileKey}{drills}{$drill}{size};
            
#           $msg = "$rname:  before substitution, source file drill size = '$size',\n";
#           print $msg;

            if (defined($drillSubstitution) && ($drillSubstitution eq "apc"))
            {
               $size = check_for_substitution($size);
            }

#           $msg = "$rname:  after substitution, source file drill size = '$size',\n";
#           print $msg;
 
            $filename = $self->{layer}{$drillFileKey}{filename};
            $msg = "$rname:  for drill file tagged '$drillFileKey'\n";
            $msg .= "$rname:  path and filename: \"$filename\"\n";
            $msg .= "$rname:  looking at drill '$drill', size '$size',\n";
            $msg .= "$rname:\n";
            print $msg if ($trace);
            

## -------------------------------------------------------------------
## Check for the presence of the current drill size in the master
## rack.  If not present, add the current drill size as a key in the
## master rack and point it to unique drill name:
## -------------------------------------------------------------------

            if ( !( exists $self->{layer}{masterRack}{$size} ) )
            {
               $newDrillName = sprintf("T%0*d", 2, $uniqueDrillCount);
               $self->{layer}{masterRack}{$size} = $newDrillName;
               $uniqueDrillCount++;
               
               if ($trace)
               {
                  $msg = "$rname:  added drill to master drill rack,\n";
                  $msg .= "$rname:  master rack now holds:\n\n";
                  print $msg if ($trace);
                  $self->{diagnostic}->show_hash($self->{layer}{masterRack}, "master drill rack");
               }

            }

            else
            {
               $msg = "$rname:  current drill already in master drill rack,\n";
               $msg .= "$rname:  \n";
               print $msg if ($trace);
            }

         } # . . . . . process all drills of current source drill file

      } # . . . . . . . . . . . . . . . . . filter for drill file keys

   } # . . . . . . . . . . . check all keys of the current drill layer




   if ($trace_master_rack_summary)
   {
      $msg  = "$rname:  SUMMARY:\n";
      $msg .= "$rname:  master drill rack just built, holds drills:\n\n";
      print $msg;
      $self->{diagnostic}->show_hash($self->{layer}{masterRack}, "master rack hash table");
   }


#--------------------------------------------------------------------#
#  Rename drills in master rack in order of ascending size:          #
#--------------------------------------------------------------------#

   $index = 1;
   foreach $size ( sort keys %{$self->{layer}{masterRack}})
   {
      $newDrillName = sprintf("T%0*d", 2, $index);
      $self->{layer}{masterRack}{$size} = $newDrillName;
      $index++; 
   }


   if ($trace)
   {
      $msg  = "$rname:  SUMMARY:\n";
      $msg .= "$rname:  master drill rack renamed in order of ascending sizes:\n\n";
      print $msg;
      $self->{diagnostic}->show_hash($self->{layer}{masterRack}, "master drill rack, ascending sizes");
   }


#--------------------------------------------------------------------#
#
#  Add new drill names to stored drill racks for each drill file to
#  be tiled...
#
#  NOTE:  source file drill racks are stored hashes with keys 
#  named as the original drill names.  The master drill rack's keys
#  are named as the drill sizes.
#
#--------------------------------------------------------------------#

   foreach $drillFileKey ( sort keys %{$self->{layer}} )
   {  
      if ( $drillFileKey =~ /^infile_/ )
      {
         foreach $drill ( keys %{$self->{layer}{$drillFileKey}{drills}} )
         {  
            $size = $self->{layer}{$drillFileKey}{drills}{$drill}{size};
            
## 2004-08-14
## Note:  with the next release, the beta version of gbtiler 2.0, the
## drill substitution option should be expanded to allow users to
## specify their own substitution value pairs.

            if (defined($drillSubstitution) && ($drillSubstitution eq "apc"))
            {
               $size = check_for_substitution($size);
            }
           
            $newDrillName = $self->{layer}{masterRack}{$size};
            $self->{layer}{$drillFileKey}{drills}{$drill}{newName} = $newDrillName; 
         }
      }
   }


   if ($trace)
   {
      $msg = "$rname:  showing full job hash tree after\n";
      $msg .= "$rname:  1) building master rack table and\n";
      $msg .= "$rname:  2) mapping new drill names to original source file drills.\n\n";
      print $msg;
      $self->{diagnostic}->show_hash_tree_primer($self->{layer});
      print "\n\n";
   }


}





sub write_master_drill_rack
{
#--------------------------------------------------------------------#
#
#  PURPOSE:
#
#--------------------------------------------------------------------#


   my $self = shift;


   my $outfile   = "";   # name of file to hold tiled drill data
   my $drillSize = "";   # drill sizes in the master drill rack
   my $drillName = "";   # drill names in the master drill rack

   my $rname   = "write_master_drill_rack";
   my $trace = $self->{trace}{$rname};
   my $msg;




## Grab the name of the file to create for the tiled information
## for a given NC drill tiling job:

   $outfile = $self->{layer}{workDirectory} . $self->{layer}{outfile};
   
 

   if (!open(OUTFILE, "> $outfile"))
   {
      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  In project '$self->{projectName}', package '$self->{packageName}',\n";
      $msg .= "$rname:  could not open '$outfile' to write drill rack data.\n";
      $msg .= "$rname:  skipping this vital step and returning to caller...\n\n";
      print $msg;
      return(0);
   }


   print OUTFILE "M48\n";

   foreach $drillSize ( sort keys %{$self->{layer}{masterRack}})
   {  
      $drillName = $self->{layer}{masterRack}{$drillSize};
      print OUTFILE ($drillName . "C" . $drillSize . "\n");
   }

   print OUTFILE "G90\n";
   print OUTFILE "M72\n";
   print OUTFILE "%\n";

   close(OUTFILE);

}





#--------------------------------------------------------------------#
#  By convention, end a package file with 1, so the use or require   #
#  command succeeds.                                                 #
#--------------------------------------------------------------------#

1;

# DrillRacks.pm
