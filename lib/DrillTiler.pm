#--------------------------------------------------------------------#
#
#   project:  gbtiler 2.0
#      file:  DrillTiler.pm
#   created:  2003-08-24
#  modified:  2007-03-05
#
#...;....1....;....2....;....3....|....4....;....5....;....6....;....7



#--------------------------------------------------------------------#
#
#  DESCRIPTION:
#
#  Convert multiple NC drill format files into a single drill file.
#  This code was designed and supports NC drill files generated by
#  the CAD softwares Protel98 and EAGLE 4.xx 
#
#
#
#
#  VERSIONS HISTORY:
#
#  2002-??-??   version 1.0
#
#  2003-07-??   version 2.0
#
#  2004-07-??   incorporation with gbtiler 2.0
#
#
#
#
#  THINGS TO ADD:
#
#  [ ]  check for INCH, INCH,LZ and METRIC commands in source NC
#       drill files,
#
#  [ ]  in the case of data in metric units, check whether
#       coordinate values are 5 or 6 digits in length,
#
#  [ ]  note in the gbtiler 2.0 user manual that the NC drill code
#       set or language has a variety of options comparable to that
#       of RS274X gerber language.  Gbtiler 2.0 does not address most
#       of NC drill language intricacies.
#
#
#
#
#  AUTHORS:
#
#  Mike Thomure
#  Ted Havelka     ted@cs.pdx.edu
#
#--------------------------------------------------------------------#



package DrillTiler;
use strict;



our ($ERRSTR);
our $self = {};




#====================================================================#
#                                                                    #
#   Constructor:                                                     #
#                                                                    #
#====================================================================#

sub new
{
#--------------------------------------------------------------------#
#  Define the run-time persistent data structure of the
#  "DrillTiler.pm" script:
#--------------------------------------------------------------------#
   my ($class) = @_; 
   $self =

   {
      projectName => 0,   # name of this package
                          # routintes

      packageName => 0,   # name of this package

      diagnostic  => 0,   # reference to a diagnostics package

      trace       => {},  # a hash table for tracing individual
                          # routintes



      useCount    => 0,   # running count of uses in a given tiling
                          # job

      layer       => {},  # hash of drill files to tile, plus
                          # their pertinent information

      drillBins   => {},  # hash of coordinate pair groups, each  
                          # group representing holes of a common
                          # drill size in the tiling job

      precision   => 0,   # coordinate data digit count

   };                       


#--------------------------------------------------------------------#
#  Initialize some object data:
#--------------------------------------------------------------------#

   $self->{projectName} = "NO PROJECT NAME SET";
   $self->{packageName} = "DrillTiler.pm";
   $self->{useCount}    = 0;

   $self->{precision}   = 5;

   $self->{trace}{new}                  = 0;
   $self->{trace}{initialize}           = 0;
   $self->{trace}{check_leading_zeroes} = 0;
   $self->{trace}{offset_and_merge}     = 0;
   $self->{trace}{write_drill_data}     = 0;



#--------------------------------------------------------------------#
#  Let the data structures of this object know their class:
#--------------------------------------------------------------------#

   bless($self, $class); 

   return $self ;

}





sub initialize
{
#--------------------------------------------------------------------#
#
#  RECEIVE:  +  a reference to a diagnostics object
#
#            +  an optional debug string to enable or disable
#               tracing of various routines in this package.
#
#  RETURN:   nothing
#
#  PURPOSE:  This routine initializes some of the data members that
#  are a part of this Perl package, and function in a global way
#  while a program which includes this package is executing.
#
#--------------------------------------------------------------------#

   my $self  = shift;

   my $rname  = "initialize";  # name of this routine
   my $debug_mode = "";        # local string holds optional param'
   my $trace = 0;              # toggle routine self tracing on/off
   my $msg = "";               # local string for diagnostics


#--------------------------------------------------------------------#
#  Set a reference to a diagnostics package:                         #
#--------------------------------------------------------------------#

   if (@_)
   {
      $self->{diagnostic} = shift;
   }
   else
   {
      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  In an instance of $self->{package}, project '$self->{projectName}'\n";
      $msg .= "$rname:  received no reference to 'Diagnostics' package instance.\n\n";
      print $msg;
   }


   if (@_)
   {
      $self->{projectName} = shift;
   }
   else
   {
      $msg = "$rname:  in package '$self->{packageName}' received no";
      $msg .= " project name during initialization.\n\n";
      print $msg;
   }

}





#====================================================================#
#                                                                    #
#   Data access methods:                                             #
#                                                                    #
#====================================================================#


sub check_leading_zeroes
{
#--------------------------------------------------------------------#
# 
#  PURPOSE:  to check for the presence of leading zeroes in source
#            NC drill files,
# 
# 
#  RECEIVE:  a layer hash table of the current tiling job,
# 
# 
#  NC DRILL NOTES:
# 
#  As of 2004-08-06 there is a discussion of inch versus metric units
#  of measure in NC drill files in a web document located at,
#
#
#  http://www.excellon.com/applicationengineering/manuals/program.htm
#
# 
#   " Coordinates are measured either in inch or metric
#     (millimeters). Inch coordinates are in six digits (00.0000)
#     with increments as small as 0.0001 (1/10,000). Metric
#     coordinates can be measured in microns (thousandths of a
#     millimeter) in one of the following three ways:  
# 
# 
#     +  Five digit 10 micron resolution (000.00)
#
#     +  Six digit 10 micron resolution (0000.00)
#
#     +  Six digit micron resolution (000.000) "
# 
#--------------------------------------------------------------------#

   my $self = shift;


   my $drillFileKey;   # string,
   my $filename;       # string,
   my $stillParsing;   # string,
   my $line;           # string,
   my $coordinate1;    # string,
   my $coordinate2;    # string,
   #my $stillParsing;   # integer, acts as boolean flag



   my $rname = "check_leading_zeroes";
   my $trace = $self->{trace}{$rname};
   my $msg;
   my ($leadingZeroesPresent);



   $self->{layer} = shift;



   if ($trace)
   {
      $msg = "$rname:  receved layer hash containing:\n\n";
      print $msg;
#     $self{diagnostic}->show_hash_keys( $self{layer}, "layer hash contents" );
      $self->{diagnostic}->show_hash( $self->{layer}, "layer hash keys and values" );
   }



   foreach $drillFileKey ( keys %{$self->{layer}} )
   {
    
$msg = "$rname:  parsing layer key '$drillFileKey',\n";
$msg .= "$rname:  \n";
print $msg if ($trace);

      if ( $drillFileKey =~ /^infile_/ )
      {  
         $filename = $self->{layer}{$drillFileKey}{filename};
    
         if (open (DRILLFILE, "< $filename"))
         {
            $leadingZeroesPresent = 0;
            $stillParsing = 1;

            while ( defined( $line = <DRILLFILE> ) && ($stillParsing) )
            {  
               if ( $line =~ /^[XY]/ )
               {
                  ($coordinate1, $coordinate2) = $line =~ /^[XY](\d+)[XY](\d+)/;

$msg = "$rname:  line holds '$line',\n";
$msg .= "$rname:  coordinate 1 = '$coordinate1',\n";
$msg .= "$rname:  coordinate 2 = '$coordinate2',\n";
$msg .= "$rname:  \n";
print $msg if ($trace);

                  if ( ( $coordinate1 =~ /^0/ ) || ( $coordinate2 =~ /^0/ ) )
                  {  
                     $leadingZeroesPresent = 1;
                     $stillParsing = 0;
                  }

               }

            }
            $self->{layer}{$drillFileKey}{leadingZeroesPresent} = $leadingZeroesPresent;  
         }

         else
         {
            $msg = "$rname:  WARNING\n";
            $msg .= "$rname:  couldn't open drill file '$filename' for reading,\n";
            print $msg;
         }

         close(DRILLFILE);
      }

   }



}





sub offset_and_merge
{
#--------------------------------------------------------------------#
# 
#  PURPOSE:   to offset and/or merge one or more NC drill files. 
# 
#  RECEIVE:   a copy of the drill rack manager's job hash table. 
# 
# 
#  IMPLEMENTATION:
# 
#  This routine receives a reference to a hash table which represents 
#  the drill layer of a tiled circuit board file set.  Using this
#  passed, complex data structure, each source drill file is parsed
#  in turn.  NC drill tool directives and coordinate data are the
#  content of interest.
#
#  In valid NC drill files, tool directives (lines which begin with
#  'T' after the header and any embedded drill rack lines) preceed
#  coordinate data.  The routine watches for these tool directives.
#  When tool directive is encountered, a look-up of the potentially
#  new tool name takes place.  This new name maps to a particular
#  drill size in a master drill rack, which during normal tiling has
#  already been constructed by the DrillRacks package.
#
#  This offsetting routine stores drill coordinate data pairs in
#  arrays.  As of 2004-08-06, gbtiler 2.0 does not appear to suffer
#  much of a performance hit for this potentially heavy use of memory.
#  The gerber tiling scripts have been modified to immediately write
#  out to intermediate and final files the mergerd and offset data.
#  Gerber files, however, generally contain an order or two orders of
#  magnitude more coordinate data.  Storing all that data in memory
#  is suspected of causing gbtiler 1.0 to run unreasonably slowly.
#
#--------------------------------------------------------------------#
   
   my $self = {}; 
   $self = shift;
   

   my $outfile;       # string, name of tiled output file
   my $drillFileKey;  # string, hash key to current source file
   my $filename;      # string, name of current source file

   my $xOffset;               # float or real value,
   my $yOffset;               # float or real value,
   my $leadingZeroesPresent;  # integer, acts as boolean flag
   my $precision;             # integer, coordinate digit count


## These flags may not be needed:

   my $G90;           # integer, acts as boolean parsing flag
   my $M72;           # integer, acts as boolean parsing flag
   my $percent;       # integer, acts as boolean parsing flag


## The $coordinate1 and $coordinate2 variables function as both string
## and integer values, depending on whether the script looks at them
## with deference to potentially present leading zeroes, or adds
## with other integer values, thereby ignoring any leading zeroes.

   my $line;          # string, line from current source file
   my $newDrillName;  # string, new drill named from master rack
   my $onDrillName;   # integer, acts as boolean parsing flag
   my $coordinate1;   # string/integer, could be an X or a Y value
   my $coordinate2;   # string/integer, could only be a Y value

   my $rname = "offset_and_merge";
   my $trace = $self->{trace}{$rname};
   my $msg = "";
   my ($trace_offsets, $onCoordinateDate); 
   my ($newXValue, $newYValue, $onCoordinateData); 
   my ($lineindex);

## Some initial diagnostics:

   $self->{useCount}++;
   $msg = "$rname:  instance of '$self->{packageName}' starting,\n";
   $msg .= "$rname:  processing drill file '$self->{useCount}' in the current tiling job,\n";
   print $msg if ($trace);

  


## Assign the passed hash table which holds NC drill files to be
## tiled:


   $self->{layer} = shift;

   $outfile = $self->{layer}{workDirectory} . $self->{layer}{outfile};
   $precision = $self->{precision};
  



## -------------------------------------------------------------------
## Open the tiled drill output file in append mode, to add the offset
## and combined data from each of the source drill files.
##
## Note that during regular execution, the DrillRacks.pm script 
## opens the output file first in write mode.  That script writes
## the combined drill rack at the top of the output file.  This script
## appends coordinate drill data to that file.
## -------------------------------------------------------------------


  

   if (!open(OUTFILE, ">> $outfile"))
   {
      $msg  = "$rname:  ERROR:\n";
      $msg .= "$rname:  In gbtiler version 2.0,\n";
      $msg .= "$rname:  package '$self->{packageName}',\n";
      $msg .= "$rname:  could not open '$outfile' to write tiled drill file.\n\n";
      print $msg;
      return 0;
   }



   foreach $drillFileKey ( keys %{$self->{layer}} )
   {
    
## Skip layer hash entries which do not represent drill files:


      next if ($drillFileKey !~ /^infile_/);
   
      $filename = $self->{layer}{$drillFileKey}{filename};
    
      $msg = "$rname:  preparing to tile '$filename',\n";
      print $msg if ($trace);



## Attempt to open a source drill file for tiling:
      
      

      if (open(INFILE, "< $filename"))
      {
         $xOffset = $self->{layer}{$drillFileKey}{xOffset};
         $yOffset = $self->{layer}{$drillFileKey}{yOffset};
         $leadingZeroesPresent = $self->{layer}{$drillFileKey}{leadingZeroesPresent};
     
     

## Convert offsets from inches to mils:

         $xOffset *= 1000; 
         $yOffset *= 1000;
         $xOffset *= 10;     
         $yOffset *= 10;  

         $msg  = "$rname:  X offset in mils is '$xOffset',\n";
         $msg .= "$rname:  Y offset in mils is '$yOffset',\n\n";
         print $msg if ($trace_offsets);

## -------------------------------------------------------------------
## So here is the main coordinate data parsing loop.  We start by
## setting a flag named $onCoordinateDate" equal to zero.  We want to
## pass over header information, if present, so as not to treat these
## lines as coordinate data, which they are not:
## -------------------------------------------------------------------

         $onCoordinateDate = 0;
         $G90 = 0;
         $M72 = 0;
         $percent = 0;
         $lineindex = 0;
         while ($line = <INFILE>)
         {


## Remove unwanted trailing white space, including carriage returns
## and line feed characters:


            while ($line =~ /\s$/) { chop($line = $line); }

            print "$rname:  looking at line '$line',\n" if ($trace);

            if ($onCoordinateData)
            {

#          .
#   .......
#  .



## Substitute old drill names with new drill names...  Note that
## drill name lines preceed blocks of coordinate data, indicating
## what size drill to use for the holes that follow, up until the
## next drill name line.


   if ( $line =~ /^T\d+/ )
   {
      
      while ($line =~ /\s$/) { chop($line = $line); }
      if (defined($self->{layer}{$drillFileKey}{drills}{$line}{newName})) {
      $newDrillName = $self->{layer}{$drillFileKey}{drills}{$line}{newName};
      $onDrillName = 1;
              
      $msg  = "$rname:  encountered drill change line,\n"; 
      $msg .= "$rname:  changing drill name '$line' to '$newDrillName'.\n";
      print $msg if ($trace); 
      }

   }

   else
   {
      $onDrillName = 0;
   }



## Process coordinate data, which should come in lines which begin
## with 'X' or 'Y':
## -------------------------------------------------------------------

#  if ( $line =~ /^(?:([XY])(\d+))(?:[XY](\d+))?$/ )

   if ( $line =~ /^[XY]\d+/ )
   {


## -------------------------------------------------------------------
# 
#     ($label1, $coordinate1, $label2, $coordinate2) = 
#     $line =~ ( /^([XY])(\d+)([Y])(\d+)/ );
# 
## Here with this regular expression we allow Perl's built-in
## variables $1..$4 to take the values from the current line which are
## expressed within the parathetical pairs of the regular expression.
## Because some drill files express only the changing coordinates of
## the X,Y data pairs, there are times when the second label and the
## second datum are not present.
##
## By testing the built-in variables for zero length, this routine can
## hold onto previous coordinate data that haven't changed since the
## previous line and are omitted from the current line.  Gbtiler 2.0
## automatically puts both NC drill coordinates in each merged,
## offset line of the tiled output file.
##
## -------------------------------------------------------------------


      $line =~ ( /^([XY])(\d+)([Y])*(\d+)*/ );

      $msg = "$rname:  current line = '$line'\n";
      $msg .= "$rname:  label 1 -> '$1'\n";
      if (defined($3)) {     $msg .= "$rname:  label 2 -> '$3'\n"; }  
      if(defined($2)) {     $msg .= "$rname:  coordinate 1 -> '$2'\n"; } 
      if(defined($4)) {     $msg .= "$rname:  coordinate 2 -> '$4'\n"; } 
      $msg .= "$rname:  \n"; 
      print $msg if ($trace);
     

## If leading zeroes are present, then add trailing zeroes if they
## are missing:
##
## NOTE:  This step may not be necessary, as the NC drill file
## document at "http://www.excellon.com/applicationengineering/manuals/program.htm"
## says that only leading or trailing zeroes should be entered to
## create correct NC drill programs.
## -------------------------------------------------------------------

      if ( length($2) > 0 )
      {
         if ($leadingZeroesPresent)
         {
#           $coordinate1 = $coordinate1 . ( "0" x ($precision - length($coordinate1)) );
            $coordinate1 = $2 . ( "0" x ($precision - length($2)) );
         }
         else
         {
#           $coordinate1 = sprintf("%0*d", $precision, $coordinate1);
            $coordinate1 = sprintf("%0*d", $precision, $2);
         }
      }


      if ( defined($4) && (length($4) > 0) )
      {
         if ($leadingZeroesPresent)
         {
#           $coordinate2 = $coordinate2 . ( "0" x ($precision - length($coordinate2)) );
            $coordinate2 = $4 . ( "0" x ($precision - length($4)) );
         }

         else
         {
#           $coordinate2 = sprintf("%0*d", $precision, $coordinate2);
            $coordinate2 = sprintf("%0*d", $precision, $4);
         }
      }


      $msg = "$rname:  after addition of leading or trailing zeroes,\n";
      $msg .= "$rname:  '$1' coordinate holds '$coordinate1'\n";
      if ( defined($3) && ($3 eq 'Y') )
      {
         $msg .= "$rname:  '$3' coordinate holds '$coordinate2'\n";
      }
      $msg .= "$rname:  \n";
      print $msg if ($trace);



## Offset X and Y coordinate values, handle the cases where there may
## be only an X or only a Y value on a particular line:
## -------------------------------------------------------------------

      if ( !( defined($3) ) )
      {
         if ($1 eq 'X')
         {
            $newXValue = $xOffset + $coordinate1;
         }

         else
         {
            $newYValue = $yOffset + $coordinate1;
         }
      }

      else
      {
         $newXValue = $xOffset + $coordinate1;
         $newYValue = $yOffset + $coordinate2;
      }



## %%%
## %%%
##
## Here would be a place to add conditional code to toggle between
## formatting offset data with leading zeroes or trailing zeroes:
## -------------------------------------------------------------------

    #  $newXValue = sprintf("%0*d", $precision, $newXValue);  
    #  $newYValue = sprintf("%0*d", $precision, $newYValue); 

      $msg = "$rname:  new X value = '$newXValue'\n";
      $msg .= "$rname:  new Y value = '$newYValue'\n"; 
      print $msg if ($trace); 
     


## Write new coordinate values to a drill bin, an entry in a hash
## table that allows this script to gather together drills of a given
## size from all source files into a single array:
## -------------------------------------------------------------------
      if (defined($newDrillName)) {
      $msg = "$rname:  adding coordinate pair to drill bin '$newDrillName',\n"; 
      print $msg if ($trace); }

      $line = "X" . $newXValue . "Y" . $newYValue;
      if (defined($newDrillName)) {
      push( @{$self->{drillBins}{$newDrillName}}, $line);
      }
   }
   print "\n" if ($trace);

#  .
#  .
#   ..     
#     ....  
#         ..
#           .
#           .



## Here set flag to determine whether to treat lines as coordinate
## data or not.  As of 2004-08-06, the commonality present in both
## drill files with embedded racks and those with external racks is
## a line with a single '%' character.  The $G90 and $M72 flags have
## been commented out here and may be removed altogether after further
## testing:
## -------------------------------------------------------------------


            }

#           $G90 = 1 if ( $line =~ /^G90/ );
#
#           $M72 = 1 if ( $line eq "M72");

            if ( $line =~ /^%/ ) {
                $percent = 1; 
            }
      
            if ($percent)
            {
               $onCoordinateData = 1;
               $G90 = 0;
               $M72 = 0;
               $percent = 0;
            }



            if ($line =~ /^M30/)
            {
               $onCoordinateData = 0;

               $msg = "$rname:  encountered an M30 drill tag,\n";
               $msg .= "$rname:  no longer on coordinate data for file '$filename',\n";
               $msg .= "$rname:  \n";
               print $msg if ($trace);
            }

         }
         close(INFILE);
      }


      else
      {
         $msg = "$rname:  WARNING\n";
         $msg .= "$rname:  could not open source drill file '$filename', \n";
         $msg .= "$rname:  continuing...\n";
         $msg .= "$rname:  \n";
         print $msg;
      }

   }


#--------------------------------------------------------------------#
#  Write tiled data to the output file:                              #
#--------------------------------------------------------------------#

   if ($trace)
   {
      $msg = "$rname:  finished creating bins of coordinate data for each drill size,\n";
      $msg .= "$rname:  drill bins are:\n";
      print $msg;

      $self->{diagnostic}->show_hash($self->{drillBins}, "drill holes sorted by size");

      $msg = "$rname:  calling routine to write tiled, offset coordinate data to file...\n\n";
      print $msg;
   }


   write_drill_data();

}





sub write_drill_data
{
#---------------------------------------------------------------------
#  2004-07-15
#
#  PURPOSE:
#
#  This routine is pretty simple, writing out the coordinates for
#  holes of each size to drill.  These are stored in a sub hash of
#  the NC drill layer passed to this script.  
#
#
#  IMPLEMENTATION NOTE:
#
#  This routine called internally
#
#---------------------------------------------------------------------


   my $outfile        = "";
   my $drill          = "";
   my $coordinatePair = "";


   my $rname = "write_drill_data";
   my $trace = $self->{trace}{$rname};
   my $msg;



   $outfile = $self->{layer}{workDirectory} . $self->{layer}{outfile};
   
   

   if (open(OUTFILE, ">> $outfile"))
   {
      foreach $drill ( keys %{$self->{drillBins}} )
      {  
         print OUTFILE ($drill . "\n");

         $msg = "$rname:  writing data for drill '$drill',\n";
         print $msg if ($trace);

         foreach $coordinatePair ( @{$self->{drillBins}{$drill}} )  
         {  
            print OUTFILE ($coordinatePair . "\n");

#           $msg = "$rname:  for drill '$drill' writing coordinate data '$coordinatePair',\n";
#           print $msg if ($trace);
         }
      }
      print "\n\n" if ($trace);
   }

   else
   {

      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  could not open '$outfile' to write tiled drill data,\n";
      $msg .= "$rname:  returning to caller...\n";
      print $msg;

      close(OUTFILE);
      return(0); 

   }


   print OUTFILE "M30\n";
   close(OUTFILE);

}





#--------------------------------------------------------------------#
#  By convention, end a package file with 1, so the use or require   #
#  command succeeds.                                                 #
#--------------------------------------------------------------------#

1;

# DrillRacks.pm

