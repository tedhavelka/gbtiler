#---------------------------------------------------------------------
#
#   project:  gbtiler 2.0
#  filename:  Header.pm
#   created:  2002-11-16
#  modified:  2007-03-05
#
#
#  This Perl module of the Gerber tiler contains routines to,
#
#...;....1....;....2....;....3....|....4....;....5....;....6....;....7



#--------------------------------------------------------------------#
#
#  DESCRIPTION:
#
#  This package of gbtiler 2.0 works on one layer of a tiling job at
#  at a time, extracting and storing header lines from the gerber
#  files of the current layer being tiled.  As of 2004-07-17, the only
#  header line gbtiler modifies is the line beginning with 'FS'.
#  There's a routine in this package to build a file statement or 'FS'
#  line based on the formatting options specified for the current
#  tiling job.
#
#  Author Ted Havelka is storing the header lines for each file as a
#  step in researching whether there may be other important header
#  lines or conflicting header lines between gerbers generated by
#  different CAD programs.  This issue hasn't shown itself yet, but
#  then again the author has only used gbtiler to tile and merge
#  files generated by EagleCAD and Protel98.
#
#
#
#
#  GERBER CODES:
#
#
#  Directive parameters:          |      Aperture parameters:
#                                 |
#     AS   Axis Select            |         AD   Aperture Description
#     FS   Format Statement       |         AM   Aperture Macro
#     MI   Mirror Image           |
#     MO   Mode of units          |
#     OF   Offset                 |      Layer-specific parameters:
#     SF   Scale Factor           |
#                                 |         KO   Knockout
#                                 |         LN   Layer Name
#  Image parameters:              |         LP   Layer Polarity
#                                 |         SR   Step and Repeat
#     IJ   Image Justify          |
#     IN   Image Name             |
#     IO   Image Offset           |      Other parameters:
#     IP   Image Polarity         |
#     IR   Image Rotation         |         IF   Include File
#     PF   Plotter Film           |
#
#
#
#
#  SOME SAMPLE GERBER FILE HEADERS:
#
#  Limor's wide-band voltage controlled oscillator gerber header:
#
#     G75*^M
#     G70*^M
#     %OFA0B0*%^M
#     %FSLAX24Y24*%^M
#     %IPPOS*%^M
#     %LPD*%^M
#
#
#  Ted's LV1B relay board top layer gerber header: 
#
#     G75*
#     G70*
#     %OFA0B0*%
#     %FSAX24Y24*%
#     %IPPOS*%
#     %LPD*%
#
#
#
#
#  IMPLEMENTATION:
#
#  This code receives a reference to a hash representing a set of
#  gerber files that are to be tiled and merged as a layer in a board
#  job.  To each key that holds individual source file information,
#  add a sub-key which holds the handful of header lines for this 
#  file.  These lines typically number less than ten.
#
#
#
#  AUTHORS:
#
#  Mike Thomure
#  Ted Havelka     ted@cs.pdx.edu
#
#--------------------------------------------------------------------#



package Header;
use strict;
our $self = {};



#====================================================================#
#                                                                    #
#   Constructor:                                                     # 
#                                                                    #
#====================================================================#

sub new
{
#--------------------------------------------------------------------#
#  The header object defined here is a hash table containing,
#
#   +  a list and,
#   +  and a nested hash
#
#--------------------------------------------------------------------#
   my ($class) = @_; 
   $self =

   {

      xIntegerDigitsRequested => 0,   #
      xDecimalDigitsRequested => 0,   #
      yIntegerDigitsRequested => 0,   #
      yDecimalDigitsRequested => 0,   #



      projectName => 0,      # name of project to which this package
                             # belongs

      packageName => 0,      # name of this package

      diagnostic => 0,       # reference to a diagnostics package

      trace=> {},            # a sub-hash of flags for tracing and
                             # and diagnostics generation on a
                             # per-routine basis

   };


#--------------------------------------------------------------------#
#  Initialize some parts of this package's internal data structure:
#--------------------------------------------------------------------#

   $self->{packageName} = "Header.pm";

   $self->{trace}{new}                    = 0;
   $self->{trace}{initialize}             = 0;
   $self->{trace}{store_headers}          = 0;
   $self->{trace}{check_gerber_precision} = 0;
   $self->{trace}{store_numeric_formats}  = 0;
   $self->{trace}{write_header}           = 0;



   bless($self, $class); 

   return $self;

}





#====================================================================#
#                                                                    #
#   Data access routines:                                            # 
#                                                                    #
#====================================================================#


sub initialize
{

   my $self = shift;

   my $rname = "initialize";
   my $trace = $self->{trace}{$rname};
   my $msg = "";




   if ($trace)
   {
      $msg = "$rname:  in package 'Header.pm' initializing,\n";
      print $msg;
   }




## Set a reference to a diagnostics package:

   if (@_)
   {
      $self->{diagnostic} = shift;
   }
   else
   {
      $msg  = "$rname:  ERROR\n";
      $msg .= "$rname:  In an instance of '$self->{packageName}' package, received\n";
      $msg .= "$rname:  no reference to 'Diagnostics' package instance.\n";
      $msg .= "$rname:  \n";
      print $msg;
   }




## If passed, set the name of the project to which this package
## belongs:

   if (@_)
   {
      $self->{projectName} = shift;
   }


}





sub store_headers
{
#--------------------------------------------------------------------#
#
#  RECEIVE:  a reference to a hash table, representing the layer
#            of gerber files currently being tiled.
#
#  RETURN:   nothing explicitly, but implicitly the passed layer
#            hash table or tree gets new information, the header lines
#            from each gerber file added to those files' other info.
#
#  PURPOSE:  to extract and store RS274X gerber lines that belong to
#            the header of the gerber input files in the passed layer.
#
#--------------------------------------------------------------------#

   my $self = shift;   # reference to instance of this package


   my $onHeader;   # integer acting as boolean flag
   my $key;        # string, name of hash key
   my $filename;   # string, local
   my $line;       # string, local

   my $rname = "store_headers";
   my $trace = $self->{trace}{$rname};
   my $msg;



## Set a boolean flag used in the header parsing loop:

   $onHeader = 1;



## Assign the first explicitly passed parameter to the local variable
## 'layer':

   if (@_)
   {
      $self->{layer} = shift;
   }
   else
   {
      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  in package '$self->{packageName}' received no gerber layer to parse,\n";
      $msg .= "$rname:  returning to caller...\n\n";
      print $msg;
      return (0);
   }



## Cycle through keys of the passed gerber layer, acting on keys that
## refer to gerber input files.  For each of these extract header
## lines from the file and store them in the corresponding gerber
## file sub-key:

   foreach $key ( keys %{$self->{layer}} )
   {
      if ( $key =~ /^infile_/ )
      {
         $filename = $self->{layer}{$key}{filename};


         if (open(INFILE, "< $filename"))
         {
            $self->{layer}{$key}{header} = ();
            while ( defined($line = <INFILE>) && ($onHeader) )
            {

## The first aperture or macro definition in most or all gerber files
## signals the end of what author Ted terms 'header' information.
## This conditional tests for such aperture and macro definitions:

               if ( $line !~ /^%A[MD]/ )
               {

## Remove white space:

                  while ( $line =~ /\s$/ )
                  {
                     chop( $line = $line );
                  }
                  push( @{$self->{layer}{$key}{header}}, $line );
               }
               else
               {
                  $onHeader = 0;
               }
            }
            close(INFILE);
            $onHeader = 1;
         }
         else
         {
            print "$rname:  couldn't open '$filename'\n"; 
         }

      }

   }


}





sub check_gerber_precision
{
#--------------------------------------------------------------------#
#
#  PURPOSE:
#
#  Verify and if necessary modify the user's requested numeric
#  precision for gerber files for layers of the current tiling job.
#  This routine assures that numeric precision for all output gerber
#  files is the same and is at least the precision found in the most
#  precise of the source gerber files for the current tiling job.
#
#--------------------------------------------------------------------#

   my $self = {};
   $self = shift;

   my $sourceFileKey;    # string,
   my $sourceFile;       # string,


   my $rname = "check_gerber_precision";
   my $trace = $self->{trace}{$rname};
   my $msg;
   my ($layerKey, $headerLine) = (0, 0); 
   my ($xIntegerDigitsOriginal, $xDecimalDigitsOriginal) = (0, 0); 
   my ($yIntegerDigitsOriginal, $yDecimalDigitsOriginal)= (0, 0); 
## Set a reference to the full tiling job:

   $self->{job} = shift;



## Set a reference to the user's requested numeric precision:

   $self->{format} = shift;




   foreach $layerKey ( keys %{$self->{job}} )
   {  
      if ( $layerKey =~ /^layer_/ )
      {
         foreach $sourceFileKey ( keys %{$self->{job}{$layerKey}} )
         {  
            if ( $sourceFileKey =~ /^infile/ )
            {
               foreach $headerLine ( @{$self->{job}{$layerKey}{$sourceFileKey}{header}} )
               {
                
                  $msg = "$rname:  examining header line '$headerLine',\n";
                  print $msg if ($trace);


                  if ( $headerLine =~ /FS/ )
                  {
                     ($xIntegerDigitsOriginal, $xDecimalDigitsOriginal,
                     $yIntegerDigitsOriginal, $yDecimalDigitsOriginal) = 
                     $headerLine =~ /[AX](\d)(\d)[BY](\d)(\d)/;
                   
                     last;
                  }
               }

## According to the gerber specification X and Y data should be
## formatted the same way, so we only check the format for X data and
## then modify the user's requested format for both X and Y output
## data:
 
               if ( $xIntegerDigitsOriginal > $self->{format}{xIntegerDigitsRequested} )
               {
                  $msg = "$rname:  increasing integer precision from '" . 
                  $self->{format}{xIntegerDigitsRequested} . "' to '" .
                  $xIntegerDigitsOriginal . "',\n";
                  print $msg if ($trace);

                  $self->{format}{xIntegerDigitsRequested} = $xIntegerDigitsOriginal;
                  $self->{format}{yIntegerDigitsRequested} = $xIntegerDigitsOriginal;
               }

               if ( $xDecimalDigitsOriginal > $self->{format}{xDecimalDigitsRequested} )
               {
                  $msg = "$rname:  increasing decimal precision from '" . 
                  $self->{format}{xDecimalDigitsRequested} . "' to '" .
                  $xDecimalDigitsOriginal . "',\n";
                  print $msg if ($trace);

                  $self->{format}{xDecimalDigitsRequested} = $xDecimalDigitsOriginal;
                  $self->{format}{yDecimalDigitsRequested} = $xDecimalDigitsOriginal;
               }
            }
         }
      }
   }



## -------------------------------------------------------------------
## Ensure that integer and decimal precision values are within bounds
## of the gerber 6.6 specification:
## -------------------------------------------------------------------

   if ( ( $self->{format}{xIntegerDigitsRequested} > 6 ) || ( $self->{format}{yIntegerDigitsRequested} > 6 ) )
   {  
      $self->{format}{xIntegerDigitsRequested} = 6;
      $self->{format}{yIntegerDigitsRequested} = 6;
   }

   if ( ( $self->{format}{xDecimalDigitsRequested} > 6 ) || ( $self->{format}{yDecimalDigitsRequested} > 6 ) )
   {
      $self->{format}{xDecimalDigitsRequested} = 6;
      $self->{format}{yDecimalDigitsRequested} = 6;
   }



## -------------------------------------------------------------------
## Ensure that X and Y precision values match:
## -------------------------------------------------------------------

   if ( $self->{format}{xIntegerDigitsRequested} > $self->{format}{yIntegerDigitsRequested} )
   {
      $self->{format}{yIntegerDigitsRequested} = $self->{format}{xIntegerDigitsRequested};
   }

   if ( $self->{format}{yIntegerDigitsRequested} > $self->{format}{xIntegerDigitsRequested} )
   {
      $self->{format}{xIntegerDigitsRequested} = $self->{format}{yIntegerDigitsRequested};
   }



   if ( $self->{format}{xDecimalDigitsRequested} > $self->{format}{yDecimalDigitsRequested} )
   {
      $self->{format}{yDecimalDigitsRequested} = $self->{format}{xDecimalDigitsRequested};
   }

   if ( $self->{format}{yDecimalDigitsRequested} > $self->{format}{xDecimalDigitsRequested} )
   {
      $self->{format}{xDecimalDigitsRequested} = $self->{format}{yDecimalDigitsRequested};
   }



}





sub store_numeric_formats
{
#---------------------------------------------------------------------
#
#  PURPOSE:
#
#  To copy X and Y numeric formatting values from the job hash table
#  to the local data structure within a running instance of this
#  package.  This allows the headers package to construct a gerber
#  format statement which matches the user's requested numeric format.
#
#  Note that if the user requests a numeric format with less precision
#  than any of the source gerber files, then the 'check gerber
#  precision' routine of this package will modify the user's requested
#  format to permit all the data from source files to output to the
#  final, tiled files for each gerber layer.
#
#  Drill file numeric formatting works a little differently.  NC drill
#  files have fixed precision, either 2.3 for inch measurements or
#  one of 2.3 or 3.3 precision for metric measurements.  The first
#  number represents integer digits in these cases, and the second
#  represents decimal precision.  As with gerber data, no decimal
#  point appears in NC drill data.
#
#---------------------------------------------------------------------

   my $self = shift;


   my $format = shift;


   my $rname = "store_numeric_formats";
   my $trace = $self->{trace}{$rname};
   my $msg = "";



   $self->{xIntegerDigitsRequested} = $format->{xIntegerDigitsRequested};

   $self->{xDecimalDigitsRequested} = $format->{xDecimalDigitsRequested};

   $self->{yIntegerDigitsRequested} = $format->{yIntegerDigitsRequested};

   $self->{yDecimalDigitsRequested} = $format->{yDecimalDigitsRequested};



   if ($trace)
   {
      $msg = "$rname:  Storing numeric formats within package '$self->{packageName}',\n";
      $msg .= "$rname:  \n";
      $msg .= "$rname:  X integer digit count = '$self->{xIntegerDigitsRequested}'\n";
      $msg .= "$rname:  X decimal digit count = '$self->{xDecimalDigitsRequested}'\n";
      $msg .= "$rname:  Y integer digit count = '$self->{yIntegerDigitsRequested}'\n";
      $msg .= "$rname:  Y decimal digit count = '$self->{yDecimalDigitsRequested}'\n\n";
      print $msg;
   }

}





sub write_header
{
#---------------------------------------------------------------------
#
#  RECEIVE:  a reference to the current gerber layer being tiled,
#
#
#  RETURN:   nothing,
#
#
#  PURPOSE: 
#
#  As of 2004-07-27 this routine writes out the header of the first
#  source file, leaving most lines unchanged.  The line which this
#  routine modifies is the Format Statement line, which looks
#  something like this,
#
#     %FSLAX25Y25*%
#
#  This line contains information about:
#
#   Leading zeroes *
#   absolute versus Incremental coordinate values
#   X integer digit count
#   X decimal digit count
#   Y integer digit count
#   Y decimal digit count
#
#
#  Breaking the line down,
#
#     %FSLAX25Y25*%
#        || || ||
#        || || |+---->  Y decimal digit count
#        || || +----->  Y integer digit count
#        || |+------->  X decimal digit count
#        || +-------->  X integer digit count
#        |+---------->  Absolute versus Incremental coordinate values
#        +----------->  Leading zeroe suppression
#
#
#  Note:  use 'L', leading zero omission, for files with both leading
#  and trailing zeroes present (neither omitted).
#
#
#
#  ISSUES:
#
#  It's possible that different source files could have
#  conflicting gerber commands.  This package of gbtiler 2.0
#  will likely need at some point to handle issues such as opposing
#  gerber polarity commands, and the presence of some files with
#  absolute offsets and others with incremental offsets.  Actually,
#  differential offsets would compel significant changes in the
#  offsetting of coordinate data as well.
#
#---------------------------------------------------------------------

   my $self = shift;


   my $job;     # refers to a hash table passed by reference
   my $xInt;    # integer,
   my $xDec;    # integer,
   my $yInt;    # integer,
   my $yDec;    # integer,

   my $formatStatement;   # string,

   my $rname = "write_header";
   my $trace = $self->{trace}{$rname};
   my $msg;
   my ($outFile, $intermediateFile, $headerLine); 




## Grab a passed reference to the current gerber layer in the tiling
## process:


   if (@_)
   {
      $self->{layer} = shift;
   }
   else
   {
      $msg = "$rname:  ERROR\n";
      $msg .= "$rname:  in package '$self->{packageName}' received no gerber layer to parse,\n";
      $msg .= "$rname:  returning to caller...\n\n";
      print $msg;
      return (0);
   }



   $msg = "$rname:  writing header for tiled output file...\n\n";
   print $msg if ($trace);



## Author Ted normally uses longer, full word or phrase based variable
## names.  Here however for the numeric formatting information, var
## names are shorter to make the format statement construction line
## more readable.  Also, these variables are use only here across a
## few lines, so it's not as though they are poorly named variables
## showing up all over the place.
## -------------------------------------------------------------------

   $xInt = $self->{xIntegerDigitsRequested};
   $xDec = $self->{xDecimalDigitsRequested};
   $yInt = $self->{yIntegerDigitsRequested};
   $yDec = $self->{yDecimalDigitsRequested};


   $formatStatement = "%FSLAX" . $xInt . $xDec . "Y" . $yInt . $yDec . "*%";



## Open current layer's output file to write header lines:

   $outFile = $self->{layer}{outfile};
   $intermediateFile = $self->{layer}{workDirectory} . $self->{layer}{outfile} . ".MERGED";


   if ( !open(OUTFILE, "> $intermediateFile") )
   {
      $msg = "$rname:  couldn't open output file '$intermediateFile' for writing,\n";
      print $msg;
      $msg = "$rname:  unable to write header lines for current layer,\n";
      $msg .= "$rname:  returning to caller...\n\n";
      print $msg;
      return (0);
   }


   foreach $headerLine ( @{$self->{layer}{infile_0001}{header}} )
   {
      if ( $headerLine =~ /FS/ )
      {
         print OUTFILE $formatStatement . "\n";
      }
      else
      {
         print OUTFILE $headerLine . "\n";
      }
   }


   close(OUTFILE);


}





#--------------------------------------------------------------------#
#  By convention, end a package file with 1, so the use or require   #
#  command succeeds.                                                 #
#--------------------------------------------------------------------#

1;


# Header.pm

